[{"content":"[[C++]] [[A Tour of C++]]\nA Tour of C++ (2nd edition) Notes Part 1 Preface To really know a city, you have to live in it, often for years. Read C++ Core Guidelines later The Basics Many obj files can be combined by a linker When we talk about portability of C++ programs, we usually mean portability of source code C++ STL can be implemented by C++ itself C++ STL has minor uses of machine code (except thread context switching C++ is a satically typed language (every entity must be known to the compiler before it\u0026rsquo;s used) A single quote (\u0026rsquo;) can be used as a digit separator for better read. Narrowing conversions are allowed and implicitly applied when using = (but not {}), this is for C compatibility 1 2 int i1 = 7.8; // i1 becomes 7 (surprised for me) int i2 {7.8}; // error : floating-point to integer conversion C++ supports 2 notions of immutability const: \u0026ldquo;I promise not to change the value\u0026rdquo;. Value can be calculated at run time. constexpr: \u0026ldquo;To be evaluated at compile time\u0026rdquo;. Value is calculated by the compiler. constexpr can also be used for functions. A constexpr function can be used for non-constant arguments. pointer with const: char* is a mutable pointer to a mutable character/string. const char* is a mutable pointer to an immutable character/string. You cannot change the contents of the location(s) this pointer points to. Also, compilers are required to give error messages when you try to do so. For the same reason, conversion from const char * to char* is deprecated. char* const is an immutable pointer (it cannot point to any other location) but the contents of location at which it points are mutable. const char* const is an immutable pointer to an immutable character/string. constexpr example: 1 2 3 4 5 6 7 8 9 10 11 constexpr double nth(double x, int n) { double res = 1; int i = 0; while (i \u0026lt; n) { res *= x; i++; } return res; } reference \u0026amp; avoids copy of the variable, and it can be used with const together. C++ direct mapping to hardware is crucial for the performance. An uninitialized reference is invalid (int \u0026amp; r2). User-Defined Types The new operator allocates memory from ==free store== (dynamic memory, heap) Constructor: Vector(int s): elem{new double[s]}, sz{s} {}, interesting to see new in a constructor using variant is safer and easier than union . E.g.: variant\u0026lt;Node*, int\u0026gt; pp26 enum： there are 2 kinds of enumerations: enum class and plain enum 1 2 3 4 5 6 enum class Color {red, blue green}; Color x = red; // error: which red? Color z = Color::red; // OK int i = Color::red; // error Color x = Color{5}; // OK Color y {6}; // OK By default, enum class has only assignment, initialization and comparisons (== and \u0026lt;), but we can define operators to it:\n1 2 3 4 5 6 7 8 9 10 11 Color\u0026amp; operator++(Color\u0026amp; t) { switch (t) { case Color::green: return t=Color::yellow; case Color::yellow: return t=Color::red; case Color::red: return t=Color::green; } } Color light = Color::red; Color next = ++light; // next becomes green ","permalink":"https://jack-kin.github.io/posts/202209/a-tour-of-cpp-1/","summary":"[[C++]] [[A Tour of C++]]\nA Tour of C++ (2nd edition) Notes Part 1 Preface To really know a city, you have to live in it, often for years. Read C++ Core Guidelines later The Basics Many obj files can be combined by a linker When we talk about portability of C++ programs, we usually mean portability of source code C++ STL can be implemented by C++ itself C++ STL has minor uses of machine code (except thread context switching C++ is a satically typed language (every entity must be known to the compiler before it\u0026rsquo;s used) A single quote (\u0026rsquo;) can be used as a digit separator for better read.","title":"A Tour of C++ Notes (Part 1)"},{"content":"[[zeroMQ]] [[MQ]]\nZeroMQ shouldnot be regarded as a pure socket library, it should be regarded as a messaging library, a \u0026ldquo;lightweight\u0026rdquo; message queue library.\nzmq_socket(3) - 0MQ Api (zeromq.org) ZeroMQ | Socket API\nKey differences to conventional sockets Generally speaking, conventional sockets present a synchronous interface to either connection-oriented reliable byte streams (SOCK_STREAM), or connection-less unreliable datagrams (SOCK_DGRAM). In comparison, ØMQ sockets present an abstraction of an asynchronous message queue, with the exact queueing semantics depending on the socket type in use. Where conventional sockets transfer streams of bytes or discrete datagrams, ØMQ sockets transfer discrete messages.\nØMQ sockets being asynchronous means that the timings of the physical connection setup and tear down, reconnect and effective delivery are transparent to the user and organized by ØMQ itself. Further, messages may be queued in the event that a peer is unavailable to receive them.\nConventional sockets allow only strict one-to-one (two peers), many-to-one (many clients, one server), or in some cases one-to-many (multicast) relationships. With the exception of ZMQ_PAIR, ØMQ sockets may be connected to multiple endpoints using zmq_connect(), while simultaneously accepting incoming connections from multiple endpoints bound to the socket using zmq_bind(), thus allowing many-to-many relationships.\nSocket Types 不同通信pattern不同\u0026quot;socket\u0026quot;\nZeroMQ patterns are implemented by pairs of sockets with matching types.\nREQ-REP pattern connects a set of clients to a set of services. This is a remote procedure call and task distribution pattern.\nPUB-SUB pattern connects a set of publishers to a set of subscribers. This is a data distribution pattern.\nPipeline pattern connects nodes in a fan-out/fan-in pattern that can have multiple steps and loops. This is a parallel task distribution and collection pattern.\nExclusive pair pattern connects two sockets exclusively. This is a pattern for connecting two threads in a process, not to be confused with “normal” pairs of sockets.\nØMQ - The Guide - ØMQ/2.2 - The Guide (zeromq.org)\nPython Multiprocessing – ZeroMQ vs Queue | Tao te Tek (wordpress.com)\nMultithreading with ØMQ To make utterly perfect MT programs (and I mean that literally) we don\u0026rsquo;t need mutexes, locks, or any other form of inter-thread communication except messages sent across ØMQ sockets.\nBy \u0026ldquo;perfect\u0026rdquo; MT programs I mean code that\u0026rsquo;s easy to write and understand, that works with one design language in any programming language, and on any operating system, and that scales across any number of CPUs with zero wait states and no point of diminishing returns.\nIf you\u0026rsquo;ve spent years learning tricks to make your MT code work at all, let alone rapidly, with locks and semaphores and critical sections, you will be disgusted when you realize it was all for nothing. If there\u0026rsquo;s one lesson we\u0026rsquo;ve learned from 30+ years of concurrent programming it is: just don\u0026rsquo;t share state. It\u0026rsquo;s like two drunkards trying to share a beer. It doesn\u0026rsquo;t matter if they\u0026rsquo;re good buddies. Sooner or later they\u0026rsquo;re going to get into a fight. And the more drunkards you add to the table, the more they fight each other over the beer. The tragic majority of MT applications look like drunken bar fights.\n","permalink":"https://jack-kin.github.io/posts/202209/zeromq/","summary":"[[zeroMQ]] [[MQ]]\nZeroMQ shouldnot be regarded as a pure socket library, it should be regarded as a messaging library, a \u0026ldquo;lightweight\u0026rdquo; message queue library.\nzmq_socket(3) - 0MQ Api (zeromq.org) ZeroMQ | Socket API\nKey differences to conventional sockets Generally speaking, conventional sockets present a synchronous interface to either connection-oriented reliable byte streams (SOCK_STREAM), or connection-less unreliable datagrams (SOCK_DGRAM). In comparison, ØMQ sockets present an abstraction of an asynchronous message queue, with the exact queueing semantics depending on the socket type in use.","title":"ZeroMQ"},{"content":"Hello I\u0026rsquo;m Zhejian Jin. I\u0026rsquo;m currently a Master Student at Columbia University, and I will graduate at Dec, 2022.\nMy Resume: Resume\n","permalink":"https://jack-kin.github.io/about/","summary":"Hello I\u0026rsquo;m Zhejian Jin. I\u0026rsquo;m currently a Master Student at Columbia University, and I will graduate at Dec, 2022.\nMy Resume: Resume","title":""}]